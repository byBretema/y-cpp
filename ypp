#!/usr/bin/env python

import os
import shutil
import argparse
import re
from collections import defaultdict

import vendor.y as y

################################################################################
### Globals
################################################################################

BUILD_DIR: str = "build"
TESTS_DIR: str = "tests"

Y_LIBS: str = "y_meta_libs"
Y_TESTS: str = "y_meta_tests"

CMAKE_TO_IGNORE = {"clean", "help", "rebuild_cache", "edit_cache", "package", "package_source", "build.ninja"}


################################################################################
### Utils
################################################################################


def run_silent(bin_path):
    return y.run_cmd([bin_path], verbosity=0, permissive=True, external=True)


class ExecStats:
    def __init__(self) -> None:
        self.total = 0
        self.passed = 0


def iter_bin_dir(
    bin_dir,
    ok_str="",
    fail_str="",
    dir_filter="",
    reverse_dir_filter=set(),
    file_filter="",
    reverse_file_filter=set(),
):

    stats = ExecStats()

    for root, dirs, files in os.walk(bin_dir):
        rel_path = os.path.relpath(root, bin_dir)

        if dir_filter and not rel_path.startswith(dir_filter):
            dirs[:] = []
            continue

        dirs[:] = [d for d in dirs if d not in reverse_dir_filter]

        for filename in files:

            if file_filter and filename != file_filter:
                continue

            if filename in reverse_file_filter:
                continue

            bin_path: str = f"{root}/{filename}"

            if not y.file_is_binary(bin_path):
                continue

            stats.total += 1

            p: y.RunCmdInfo = run_silent(bin_path)
            ok: bool = not p.returncode
            status: str = ok_str if ok else fail_str

            with y.temp_width(60):
                y.println(f"\n‚îå‚îÄ‚îÄ ‚Ä¢ {filename} ‚Ä¢")

                if p.stdout:
                    # ... Raw to file
                    with open(f"{root}/log__{filename}.txt", "w") as file:
                        file.write(p.stdout)
                    # ... Beautify to console
                    y.println("‚îÇ  ")
                    for line in p.stdout.strip("\n").split("\n"):
                        y.println(f"‚îÇ  {line}")

                y.println("‚îÇ  ")
                y.print_fill("‚îî{s}‚ñ∏ {m}" "\n", "‚îÄ", m=status)

            stats.passed += int(ok)

    return stats


class CMakeUserTargets:
    def __init__(self) -> None:
        self.binaries = list()
        self.tests = list()

    def all(self):
        return self.binaries + self.tests

    def contains(self, target_name: str) -> bool:
        return target_name in (self.binaries + self.tests)


def cmake_user_targets(cwd: str) -> CMakeUserTargets:
    p: y.RunCmdInfo = y.run_cmd(
        ["cmake", "--build", cwd, "--target", "help"],
        verbosity=0,
        permissive=True,
    )
    if p.returncode:
        return CMakeUserTargets()

    # Extract y.cmake dependencies from CMake cache
    cache_file = os.path.join(cwd, "CMakeCache.txt")
    libs: set[str] = set()
    tests: set[str] = set()

    if not os.path.exists(cache_file):
        return CMakeUserTargets()

    # Extract libs
    with open(cache_file, "r") as f:
        match = re.search(f"{Y_LIBS}:(.*)=(.+)", f.read(), re.IGNORECASE)
        libs = {lib for lib in match.group(2).strip().split(" ")} if match else set()

    # Extract tests
    with open(cache_file, "r") as f:
        match = re.search(f"{Y_TESTS}:(.*)=(.+)", f.read(), re.IGNORECASE)
        tests = {test for test in match.group(2).strip().split(" ")} if match else set()

    targets = CMakeUserTargets()
    for line in p.stdout.splitlines():

        # Validate entry
        if ":" not in line:
            continue
        name, _ = line.split(":", 1)
        name = name.strip()
        if targets.contains(name):
            continue

        # Skip meta-targets
        if not name or "/" in name or name in CMAKE_TO_IGNORE:
            continue

        # Skip y.cmake dependencies
        name_lower = name.lower()
        if any(lib.lower() in name_lower or name_lower in lib.lower() for lib in libs):
            continue

        # Append to list and decorate for tests
        if name in tests:
            targets.tests.append(name)
        else:
            targets.binaries.append(name)

    return targets


def norm_target_name(target_name: str) -> list[str]:
    to_print = f" : {target_name}"
    if not target_name or target_name == "all":
        target_name = ""
        to_print = ""
    return [target_name, to_print]


################################################################################
### Config
################################################################################


def config(cwd: str, build_type: str, generator: str, build_tests: bool):
    y.print_header("CONFIG")

    y.run_cmd(
        [
            "cmake",
            "-G",
            generator,
            "../..",
            f"-DCMAKE_BUILD_TYPE={build_type}",
            "-DCMAKE_POLICY_VERSION_MINIMUM=3.10",
            f"-DY_BUILD_TESTS={"ON" if build_tests else "OFF"}",
        ],
        cwd=cwd,
    )


################################################################################
### Build
################################################################################


def build(targets: set, cwd: str, build_type: str, target_name: str = "all", ignore_set=set()):
    y.print_header("BUILD", post="")

    target_name, _ = norm_target_name(target_name)

    cmake_build_cmd = ["cmake", "--build", ".", "-j", str(os.cpu_count()), "--config", build_type]

    if not target_name and not ignore_set:
        y.run_cmd(cmake_build_cmd, cwd=cwd, pre="\n")
        return

    for target in targets:
        if target_name and target != target_name:
            continue
        if target in ignore_set:
            continue
        y.run_cmd([*cmake_build_cmd, "--target", target], cwd=cwd, pre="\n")


################################################################################
### Run
################################################################################


def run(target_name: str = "all", reverse_file_filter=set()):
    target_name, target_name_print = norm_target_name(target_name)
    y.print_header(f"RUNNING{target_name_print}", post="")

    bins_dir: str = os.path.abspath(f"{BUILD_DIR}/bin")
    y.required_folder(bins_dir, info="Bin not executed.")

    iter_bin_dir(
        bins_dir,
        ok_str="üü¢",
        fail_str="üî¥",
        file_filter=target_name,
        reverse_file_filter=reverse_file_filter,
    )


################################################################################
### Tests
################################################################################


def tests(target_name: str = "all", reverse_file_filter=set()):
    target_name, target_name_print = norm_target_name(target_name)
    y.print_header(f"TESTING{target_name_print}", post="")

    tests_dir: str = os.path.abspath(f"{BUILD_DIR}/tests")
    y.required_folder(tests_dir, info="Test(s) not executed.")

    stats = iter_bin_dir(
        tests_dir,
        ok_str="PASSED üü¢",
        fail_str="FAILED üî¥",
        file_filter=target_name,
        reverse_file_filter=reverse_file_filter,
    )
    status: str = "PASS ‚úÖÔ∏è" if (stats.passed == stats.total) else "FAIL ‚õîÔ∏è"

    y.println()
    y.log_info(f"Passed tests ({stats.passed}/{stats.total}) ‚ù± {status}")


################################################################################
### Main
################################################################################


def main():

    #! Setup

    y.setup(show_traceback=True)

    #! Args

    parser = argparse.ArgumentParser(description="y-cpp project manager companion")
    subparsers = parser.add_subparsers(dest="command", required=True)
    parser.suggest_on_error = True

    # Common options
    parser.add_argument("-c", "--clean", action="store_true", help="Cleanup projects/tests from build dir")
    parser.add_argument("-f", "--fresh", action="store_true", help="Cleanup whole build dir")
    parser.add_argument("-d", "--debug", action="store_true", help="Build in Debug mode")
    parser.add_argument("-g", "--generator", type=str, default="Ninja", help="CMake generator")

    # Command: build
    build_parser = subparsers.add_parser("build", help="Config + Build a target")
    build_parser.add_argument("-i", "--interactive", action="store_true", help="Let you choose what to build")
    build_parser.add_argument("-t", "--tests", action="store_true", help="Let you choose what to build")
    build_parser.add_argument("--ignore", nargs="+", default=[], help="Targets to ignore")
    build_parser.add_argument("target", nargs="?", default="all", help="Specific target (default: all)")

    # Command: test
    test_parser = subparsers.add_parser("test", help="Run test(s)")
    test_parser.add_argument("-i", "--interactive", action="store_true", help="Let you choose what to test")
    test_parser.add_argument("--ignore", nargs="+", default=[], help="Targets to ignore")
    test_parser.add_argument("target", nargs="?", default="all", help="Specific target (default: all)")

    # Command: run
    run_parser = subparsers.add_parser("run", help="Run a project")
    run_parser.add_argument("-i", "--interactive", action="store_true", help="Let you choose what to run")
    run_parser.add_argument("--ignore", nargs="+", default=[], help="Targets to ignore")
    run_parser.add_argument("target", nargs="?", default="all", help="Specific target (default: all)")

    # Command: add
    add_parser = subparsers.add_parser("add", help="Add a project")
    add_parser.add_argument("project_name", type=str, help="Project name")

    # Parse args
    args = parser.parse_args()

    is_build = args.command == "build"
    is_run = args.command == "run"

    is_test = args.command == "test"
    is_build_with_tests = args.command == "build" and args.tests
    require_tests = is_test or is_build_with_tests

    imply_compile = is_build or is_run or is_test

    ignore_set = set(args.ignore) if imply_compile else set()

    #! Vars

    build_type: str = "Release" if not args.debug else "Debug"
    sub_build_dir: str = f"{y.script_path()}/{BUILD_DIR}/sub-build"
    generator: str = args.generator

    #! Required

    y.required_command("cmake")

    if generator == "Ninja":
        y.required_command("ninja")

    #! Cleanup

    if args.fresh and os.path.isdir(BUILD_DIR):
        shutil.rmtree(BUILD_DIR)
    os.makedirs(BUILD_DIR, exist_ok=True)

    if args.clean and os.path.isdir(sub_build_dir):
        shutil.rmtree(sub_build_dir)
    os.makedirs(sub_build_dir, exist_ok=True)

    #! Add

    # if args.command == "add":
    #     add()
    #     return

    #! Valid command ?

    if not imply_compile:
        return

    #! Config

    config(sub_build_dir, build_type, generator, build_tests=require_tests)

    #! Interactive layer

    user_choice = args.target

    targets = cmake_user_targets(sub_build_dir)

    targets_all = targets.all()

    if user_choice and user_choice != "all" and user_choice not in targets_all:
        y.error_exit(f"Target '{user_choice}' not found", pre="")

    targets = targets.tests if is_test else targets_all if is_build_with_tests else targets.binaries
    target_type = "tests" if is_test else "test/bin" if is_build_with_tests else "bin"

    if args.interactive:
        options = ["all", *targets] if require_tests else targets
        user_choice = y.menu(options, f"Choose a {target_type} target to build", prompt="Build", starts_at=0)
        if not user_choice:
            y.error_exit("Invalid target to build")

    #! Build and Run

    build(set(targets), sub_build_dir, build_type, user_choice, ignore_set)

    if args.command == "run":
        run(user_choice, ignore_set)

    if args.command == "test":
        tests(user_choice, ignore_set)


################################################################################
### Entry Point
################################################################################

y.entrypoint(main)
